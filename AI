import requests
import pandas as pd
import numpy as np
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv
import json
import logging
import asyncio
from typing import List, Dict, Optional
from concurrent.futures import ThreadPoolExecutor
from sklearn.ensemble import RandomForestRegressor
import joblib
import serial

# Load environment variables
load_dotenv()
API_KEY = os.getenv('OPENWEATHER_API_KEY')

class WeatherPredictor:
    def __init__(self):
        self.model_path = 'models/weather_model.joblib'
        # Use RandomForest instead of DecisionTree for better predictions
        self.model = self.load_model() or RandomForestRegressor(
            n_estimators=100,
            max_depth=15,
            random_state=42
        )
        self.data_buffer = []
        self.buffer_size = 1000  # Store more historical data
        self.thread_pool = ThreadPoolExecutor(max_workers=4)
        self.setup_logging()
    
    def setup_logging(self):
        """Configure logging"""
        logging.basicConfig(
            filename='weather_predictor.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def save_model(self):
        """Save trained model to disk"""
        from joblib import dump
        try:
            dump(self.model, self.model_path)
            self.logger.info("Model saved successfully")
        except Exception as e:
            self.logger.error(f"Error saving model: {e}")

    def load_model(self):
        """Load trained model from disk"""
        from joblib import load
        try:
            if os.path.exists(self.model_path):
                return load(self.model_path)
            return None
        except Exception as e:
            self.logger.error(f"Error loading model: {e}")
            return None

    def implement_rate_limiting(self):
        """Implement basic rate limiting"""
        from time import time, sleep
        
        if not hasattr(self, '_last_request_time'):
            self._last_request_time = 0
            
        # Ensure minimum 1 second between API calls
        current_time = time()
        time_since_last = current_time - self._last_request_time
        
        if time_since_last < 1:
            sleep(1 - time_since_last)
            
        self._last_request_time = time()

    def get_current_location(self):
        """Get current location based on IP address"""
        try:
            # Add timeout and headers to improve reliability
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            self.implement_rate_limiting()
            response = requests.get('https://ipapi.co/json/', 
                                  timeout=5,
                                  headers=headers)
            response.raise_for_status()  # Raise exception for bad status codes
            data = response.json()
            
            if 'error' in data:
                raise Exception(f"API Error: {data['error']}")
                
            return {
                'city': data.get('city', 'London'),  # Default to London if city not found
                'lat': data.get('latitude', 51.5074),
                'lon': data.get('longitude', -0.1278)
            }
        except Exception as e:
            print(f"Error getting location: {e}")
            # Return default location (London) as fallback
            return {
                'city': 'London',
                'lat': 51.5074,
                'lon': -0.1278
            }

    def get_location_input(self):
        """Get location manually from user input"""
        print("\nEnter your location details:")
        city = input("City name: ")
        lat = float(input("Latitude (e.g. 51.5074 for London): "))
        lon = float(input("Longitude (e.g. -0.1278 for London): "))
        return {'city': city, 'lat': lat, 'lon': lon}
        
    def predict_from_gps(self, lat, lon):
        """Predict weather using GPS coordinates"""
        try:
            # Get weather data for the GPS location
            location = {
                'lat': lat,
                'lon': lon
            }
            
            # Get current weather data
            weather_data = self.fetch_weather_data(location)
            if not weather_data:
                raise Exception("Failed to fetch weather data")
            
            # Validate weather data
            if not self.validate_weather_data(weather_data):
                raise Exception("Invalid weather data")
            
            # Train model with historical data for this location
            self.collect_training_data(location)
            if not self.train_model():
                raise Exception("Failed to train model")
            
            # Make prediction
            will_rain = self.predict_rain(
                weather_data['temperature'],
                weather_data['humidity'],
                weather_data['pressure']
            )
            
            return {
                'current': weather_data,
                'prediction': will_rain
            }
            
        except Exception as e:
            print(f"Error in prediction: {e}")
            return None
    
    def initialize_sensors(self, port='COM3'):
        """Initialize connection to Arduino sensors"""
        try:
            self.sensor_handler = ArduinoSensorHandler(port=port)
            self.use_sensors = self.sensor_handler.connect()
            return self.use_sensors
        except Exception as e:
            self.logger.error(f"Error initializing sensors: {e}")
            return False

    def fetch_weather_data(self, location):
        """Fetch weather data from sensors or API"""
        # Try to get sensor data first
        if self.use_sensors and self.sensor_handler:
            sensor_data = self.sensor_handler.read_sensor_data()
            if sensor_data:
                return {
                    'temperature': sensor_data['temperature'],
                    'humidity': sensor_data['humidity'],
                    'pressure': sensor_data['pressure'],
                    'rain': 0  # DHT11/BME280 cannot detect rain
                }
        
        # Fallback to API if no sensor data
        cached_data = self.get_cached_weather_data(location)
        if cached_data:
            return cached_data

        base_url = "http://api.openweathermap.org/data/2.5/weather"
        params = {
            'lat': location['lat'],
            'lon': location['lon'],
            'appid': API_KEY,
            'units': 'metric'
        }
        
        try:
            self.implement_rate_limiting()
            response = requests.get(base_url, params=params)
            data = response.json()
            
            weather_data = {
                'temperature': data['main']['temp'],
                'humidity': data['main']['humidity'],
                'pressure': data['main']['pressure'],
                'rain': 1 if 'rain' in data else 0
            }
            
            self.cache_weather_data(location, weather_data)
            return weather_data
        except Exception as e:
            print(f"Error fetching data: {e}")
            return None

    def validate_weather_data(self, data):
        """Validate weather data"""
        try:
            required = ['temperature', 'humidity', 'pressure']
            if not all(k in data for k in required):
                self.logger.error("Missing required weather parameters")
                return False
                
            # Validate ranges
            valid_ranges = {
                'temperature': (-50, 60),
                'humidity': (0, 100),
                'pressure': (900, 1100)
            }
            
            for param, (min_val, max_val) in valid_ranges.items():
                if not min_val <= data[param] <= max_val:
                    self.logger.error(f"Invalid {param} value: {data[param]}")
                    return False
                    
            return True
            
        except Exception as e:
            self.logger.error(f"Validation error: {e}")
            return False

    def collect_training_data(self, location):
        """Collect historical weather data for training"""
        try:
            # Collect last 5 days of weather data
            end_date = datetime.now()
            start_date = end_date - timedelta(days=5)
            
            base_url = "http://api.openweathermap.org/data/2.5/onecall/timemachine"
            
            historical_data = []
            current_date = start_date
            
            while current_date <= end_date:
                params = {
                    'lat': location['lat'],
                    'lon': location['lon'],
                    'dt': int(current_date.timestamp()),
                    'appid': API_KEY,
                    'units': 'metric'
                }
                
                self.implement_rate_limiting()
                response = requests.get(base_url, params=params)
                data = response.json()
                
                if 'current' in data:
                    weather = data['current']
                    historical_data.append({
                        'temperature': weather['temp'],
                        'humidity': weather['humidity'],
                        'pressure': weather['pressure'],
                        'rain': 1 if 'rain' in weather else 0
                    })
                
                current_date += timedelta(days=1)
            
            self.data = historical_data
            return True
            
        except Exception as e:
            print(f"Error collecting training data: {e}")
            return False

    def train_model(self):
        """Train the weather prediction model"""
        try:
            if not self.data:
                return False
                
            df = pd.DataFrame(self.data)
            X = df[['temperature', 'humidity', 'pressure']]
            y = df['rain']
            
            self.model.fit(X, y)
            self.save_model()
            return True
            
        except Exception as e:
            print(f"Error training model: {e}")
            return False

    def predict_rain(self, temperature, humidity, pressure):
        """Predict if it will rain based on current conditions"""
        try:
            prediction = self.model.predict([[temperature, humidity, pressure]])
            return bool(prediction[0])
        except Exception as e:
            print(f"Error making prediction: {e}")
            return False

    def cache_weather_data(self, location, data, duration=300):
        """Cache weather data for 5 minutes"""
        cache_key = f"{location['lat']}_{location['lon']}"
        cache_file = f"cache_{cache_key}.json"
        
        cache_data = {
            'timestamp': datetime.now().timestamp(),
            'data': data
        }
        
        try:
            with open(cache_file, 'w') as f:
                json.dump(cache_data, f)
        except Exception as e:
            self.logger.error(f"Cache error: {e}")

    def get_cached_weather_data(self, location):
        """Get cached weather data if available and fresh"""
        cache_key = f"{location['lat']}_{location['lon']}"
        cache_file = f"cache_{cache_key}.json"
        
        try:
            if os.path.exists(cache_file):
                with open(cache_file, 'r') as f:
                    cache = json.load(f)
                    
                if datetime.now().timestamp() - cache['timestamp'] < 300:
                    return cache['data']
            return None
        except Exception as e:
            self.logger.error(f"Cache read error: {e}")
            return None

    def evaluate_model(self, X_test, y_test):
        """Evaluate model performance"""
        from sklearn.metrics import accuracy_score, precision_score, recall_score
        
        try:
            y_pred = self.model.predict(X_test)
            
            metrics = {
                'accuracy': accuracy_score(y_test, y_pred),
                'precision': precision_score(y_test, y_pred),
                'recall': recall_score(y_test, y_pred)
            }
            
            self.logger.info(f"Model metrics: {metrics}")
            return metrics
            
        except Exception as e:
            self.logger.error(f"Evaluation error: {e}")
            return None

    def process_sensor_data(self, data):
        """Process incoming sensor data"""
        try:
            if not data:
                return None
                
            processed_data = {
                'temperature': data.get('temperature'),
                'humidity': data.get('humidity'),
                'pressure': data.get('pressure'),
                'timestamp': datetime.now().isoformat()
            }
            
            self.data.append(processed_data)
            return processed_data
        except Exception as e:
            self.logger.error(f"Error processing sensor data: {e}")
            return None

    def predict_weather(self):
        """Generate weather prediction based on sensor data"""
        try:
            if len(self.data) < 24:  # Need at least 24 hours of data
                return "Insufficient data for prediction"
                
            recent_data = pd.DataFrame(self.data[-24:])
            X = recent_data[['temperature', 'humidity', 'pressure']]
            prediction = self.model.predict(X)
            
            return self.decode_prediction(prediction[0])
        except Exception as e:
            self.logger.error(f"Error making prediction: {e}")
            return "Prediction error"

    def decode_prediction(self, code):
        """Convert prediction code to weather description"""
        weather_codes = {
            0: "Sunny",
            1: "Partly Cloudy",
            2: "Rain",
            3: "Heavy Rain"
        }
        return weather_codes.get(code, "Unknown")
    
    async def process_sensor_stream(self, sensor_data: Dict):
        """Process incoming sensor data asynchronously"""
        try:
            # Process in thread pool to avoid blocking
            processed = await asyncio.get_event_loop().run_in_executor(
                self.thread_pool,
                self._process_data_point,
                sensor_data
            )
            
            if processed:
                self.data_buffer.append(processed)
                if len(self.data_buffer) > self.buffer_size:
                    self.data_buffer.pop(0)
                    
                # Retrain model if enough new data
                if len(self.data_buffer) % 100 == 0:
                    await self.train_model_async()
                    
            return processed
        except Exception as e:
            self.logger.error(f"Error processing sensor data: {e}")
            return None

    def _process_data_point(self, data: Dict) -> Optional[Dict]:
        """Process single data point with validation"""
        try:
            if not self.validate_weather_data(data):
                return None
                
            return {
                'temperature': float(data['temperature']),
                'humidity': float(data['humidity']), 
                'pressure': float(data['pressure']),
                'timestamp': data.get('timestamp')
            }
        except Exception as e:
            self.logger.error(f"Error processing data point: {e}")
            return None

    async def predict_next_week(self) -> List[Dict]:
        """Predict weather for next 7 days"""
        try:
            if len(self.data_buffer) < 24:  # Need at least 24 hours of data
                return []
                
            # Get recent trends
            recent_data = np.array([
                [d['temperature'], d['humidity'], d['pressure']]
                for d in self.data_buffer[-24:]
            ])
            
            predictions = []
            current = recent_data[-1]  # Start from latest reading
            
            # Predict next 7 days in 3-hour intervals
            intervals = 7 * 8  # 7 days * 8 three-hour intervals
            for i in range(intervals):
                # Predict next values using rolling window
                prediction = await asyncio.get_event_loop().run_in_executor(
                    self.thread_pool,
                    self.model.predict,
                    current.reshape(1, -1)
                )
                
                weather_code = self._get_weather_code(
                    prediction[0][0],  # temperature
                    prediction[0][1],  # humidity
                    prediction[0][2]   # pressure
                )
                
                predictions.append({
                    'hours_from_now': i * 3,
                    'temperature': float(prediction[0][0]),
                    'humidity': float(prediction[0][1]),
                    'pressure': float(prediction[0][2]),
                    'condition': self.decode_prediction(weather_code)
                })
                
                current = prediction[0]  # Use prediction as next input
                
            return predictions
            
        except Exception as e:
            self.logger.error(f"Prediction error: {e}")
            return []

    def _get_weather_code(self, temp: float, humidity: float, pressure: float) -> int:
        """Determine weather code from conditions"""
        # Enhanced weather classification logic
        if pressure < 1000:  # Low pressure system
            if humidity > 80:
                return 3  # Heavy Rain
            return 2  # Rain Likely
        elif humidity > 85:
            return 1  # Partly Cloudy
        return 0  # Clear

    async def train_model_async(self):
        """Train model asynchronously"""
        try:
            if len(self.data_buffer) < 100:
                return False
                
            data = np.array([
                [d['temperature'], d['humidity'], d['pressure']]
                for d in self.data_buffer
            ])
            
            # Use previous values to predict next values
            X = data[:-1]
            y = data[1:]
            
            await asyncio.get_event_loop().run_in_executor(
                self.thread_pool,
                self._train_model,
                X, y
            )
            
            return True
        except Exception as e:
            self.logger.error(f"Training error: {e}")
            return False

    def _train_model(self, X, y):
        """Train model in thread pool"""
        self.model.fit(X, y)
        joblib.dump(self.model, self.model_path)

class ArduinoSensorHandler:
    def __init__(self, port='COM3', baud_rate=9600):
        self.port = port
        self.baud_rate = baud_rate
        self.serial = None

    def connect(self):
        """Connect to Arduino via serial port"""
        try:
            self.serial = serial.Serial(self.port, self.baud_rate)
            return True
        except Exception as e:
            print(f"Error connecting to Arduino: {e}")
            return False

    def read_sensor_data(self):
        """Read sensor data from Arduino"""
        try:
            if not self.serial or not self.serial.is_open:
                return None
            
            # Read line from Arduino
            data = self.serial.readline().decode().strip()
            return json.loads(data)
            
        except Exception as e:
            print(f"Error reading sensor data: {e}")
            return None

async def main():
    handler = ArduinoSensorHandler()
    await handler.connect()

if __name__ == "__main__":
    asyncio.run(main())